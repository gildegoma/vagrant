# TODO adopt (good) name for the guest-based provisioner (I find ansible_local a bit unclear, but it corresponds to Packer heritage)
# TODO more lazy loading accessors (unified style)
# TODO method naming conventions: setup_, run/execute_, get/load/init?
# TODO fix config checks in guest mode
# TODO create an AnsibleHelper class? (for functions like as_list_argument or as_array)
# TODO update the docs (single page? Explain why "127.0.0.1," trick is possible but not recommended)
# TODO more duck-typing/inheritance or composition (Ã  la chef command builder)
# TODO extend and improve templates/locales/en.yml messages
# TODO clean all TODOs!!!!!!!!!


module VagrantPlugins
  module Ansible
    module Provisioner
      # This class is a base class where the common functionality shared between
      # both ansible provisioning modes are stored. This is **not an actual
      # provisioner**. Instead, {Host} or {Guest} should be used.

      class Base < Vagrant.plugin("2", :provisioner)

        class AnsibleError < Vagrant::Errors::VagrantError
          error_namespace("vagrant.provisioners.ansible")
        end

        protected

        def load_common_command_arguments

          # By default we limit by the current machine.
          # This can be overridden by the limit config option.
          @command_arguments << "--limit=#{@machine.name}" unless config.limit

          @command_arguments.concat(self.class.as_array(config.raw_arguments)) if config.raw_arguments

          @command_arguments << "--inventory-file=#{get_inventory_path}"
          @command_arguments << "--extra-vars=#{get_extra_vars_argument}" if config.extra_vars
          @command_arguments << "--sudo" if config.sudo
          @command_arguments << "--sudo-user=#{config.sudo_user}" if config.sudo_user
          @command_arguments << "#{get_verbosity_argument}" if config.verbose
          @command_arguments << "--vault-password-file=#{config.vault_password_file}" if config.vault_password_file
          @command_arguments << "--tags=#{self.class.as_list_argument(config.tags)}" if config.tags
          @command_arguments << "--skip-tags=#{self.class.as_list_argument(config.skip_tags)}" if config.skip_tags
          @command_arguments << "--limit=#{self.class.as_list_argument(config.limit)}" if config.limit
          @command_arguments << "--start-at-task=#{config.start_at_task}" if config.start_at_task
        end

        def load_common_environment_variables
          # Some Ansible options must be passed as environment variables
          @environment_variables = {
            # Ensure Ansible output isn't buffered so that we receive output
            # on a task-by-task basis.
            "PYTHONUNBUFFERED" => 1,

            # TODO: explain why it need to be forced (+ verify for guest mode...)
            "ANSIBLE_FORCE_COLOR" => "true",
          }
        end

        # Auto-generate "safe" inventory file based on Vagrantfile,
        # unless inventory_path is explicitly provided
        def get_inventory_path
          return config.inventory_path if config.inventory_path

          unless @inventory_path
            generate_inventory
          end

          return @inventory_path
        end

        def generate_inventory
          @inventory_machines = {}
          @inventory = Pathname.new(File.join(Dir.tmpdir, "vagrant_ansible_generated_inventory"))

          @inventory.open('w') do |file|
            file.write("# Generated by Vagrant\n\n")

            # This abstract step must generate the list of supported host(s)
            generate_inventory_machines(file)

            generate_inventory_groups(file)

            file.close
          end

          # This abstract step must assign @inventory_path and store the file to the correct location
          ship_generated_inventory
        end

        # Write out groups information.
        # All defined groups will be included, but only supported
        # machines and defined child groups will be included.
        # Group variables are intentionally skipped.
        def generate_inventory_groups(inventory_file)
          groups_of_groups = {}
          defined_groups = []

          config.groups.each_pair do |gname, gmembers|
            # Require that gmembers be an array
            # (easier to be tolerant and avoid error management of few value)
            gmembers = [gmembers] if !gmembers.is_a?(Array)

            if gname.end_with?(":children")
              groups_of_groups[gname] = gmembers
              defined_groups << gname.sub(/:children$/, '')
            elsif !gname.include?(':vars')
              defined_groups << gname
              inventory_file.write("\n[#{gname}]\n")
              gmembers.each do |gm|
                inventory_file.write("#{gm}\n") if @inventory_machines.include?(gm.to_sym)
              end
            end
          end

          defined_groups.uniq!
          groups_of_groups.each_pair do |gname, gmembers|
            inventory_file.write("\n[#{gname}]\n")
            gmembers.each do |gm|
              inventory_file.write("#{gm}\n") if defined_groups.include?(gm)
            end
          end
        end

        def get_extra_vars_argument
          if config.extra_vars.kind_of?(String) and config.extra_vars =~ /^@.+$/
            # A JSON or YAML file is referenced (requires Ansible 1.3+)
            return config.extra_vars
          else
            # Expected to be a Hash after config validation. (extra_vars as
            # JSON requires Ansible 1.2+, while YAML requires Ansible 1.3+)
            return config.extra_vars.to_json
          end
        end

        def get_verbosity_argument
          if config.verbose.to_s =~ /^v+$/
            # ansible-playbook accepts "silly" arguments like '-vvvvv' as '-vvvv' for now
            return "-#{config.verbose}"
          else
            # safe default, in case input strays
            return '-v'
          end
        end

        # TODO: Put the functions below into a AnsibleHelper class, intead of using class methods?

        def self.stringify_ansible_playbook_command(env, command)
          shell_command = ''
          env.each_pair do |k, v|
            if k == 'ANSIBLE_SSH_ARGS'
              shell_command += "#{k}='#{v}' "
            else
              shell_command += "#{k}=#{v} "
            end
          end

          shell_arg = []
          command.each do |arg|
            if arg =~ /(--start-at-task|--limit)=(.+)/
              shell_arg << "#{$1}='#{$2}'"
            else
              shell_arg << arg
            end
          end

          shell_command += shell_arg.join(' ')
        end

        def self.as_list_argument(v)
          v.kind_of?(Array) ? v.join(',') : v
        end

        def self.as_array(v)
          v.kind_of?(Array) ? v : [v]
        end

      end
    end
  end
end
